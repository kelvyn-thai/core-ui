import*as t from"react";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)};const n=(a={default:()=>t.default},i={},e.d(i,a),i),r=t=>Symbol.iterator in t,o=t=>"entries"in t,s=(t,e)=>{const n=t instanceof Map?t:new Map(t.entries()),r=e instanceof Map?e:new Map(e.entries());if(n.size!==r.size)return!1;for(const[t,e]of n)if(!Object.is(e,r.get(t)))return!1;return!0};var a,i;function c(t){const e=n.default.useRef(void 0);return n=>{const a=t(n);return i=e.current,c=a,Object.is(i,c)||"object"==typeof i&&null!==i&&"object"==typeof c&&null!==c&&(r(i)&&r(c)?o(i)&&o(c)?s(i,c):((t,e)=>{const n=t[Symbol.iterator](),r=e[Symbol.iterator]();let o=n.next(),s=r.next();for(;!o.done&&!s.done;){if(!Object.is(o.value,s.value))return!1;o=n.next(),s=r.next()}return!!o.done&&!!s.done})(i,c):s({entries:()=>Object.entries(i)},{entries:()=>Object.entries(c)}))?e.current:e.current=a;var i,c}}const l=new Map,u=t=>{const e=l.get(t);return e?Object.fromEntries(Object.entries(e.stores).map((([t,e])=>[t,e.getState()]))):{}},d=(t,e)=>{let n;try{n=JSON.parse(t)}catch(t){console.error("[zustand devtools middleware] Could not parse the received json",t)}void 0!==n&&e(n)};function f(t,e){let n;try{n=t()}catch(t){return}return{getItem:t=>{var r;const o=t=>null===t?null:JSON.parse(t,null==e?void 0:e.reviver),s=null!=(r=n.getItem(t))?r:null;return s instanceof Promise?s.then(o):o(s)},setItem:(t,r)=>n.setItem(t,JSON.stringify(r,null==e?void 0:e.replacer)),removeItem:t=>n.removeItem(t)}}const v=t=>e=>{try{const n=t(e);return n instanceof Promise?n:{then:t=>v(t)(n),catch(t){return this}}}catch(t){return{then(t){return this},catch:e=>v(e)(t)}}},p=t=>{let e;const n=new Set,r=(t,r)=>{const o="function"==typeof t?t(e):t;if(!Object.is(o,e)){const t=e;e=(null!=r?r:"object"!=typeof o||null===o)?o:Object.assign({},e,o),n.forEach((n=>n(e,t)))}},o=()=>e,s={setState:r,getState:o,getInitialState:()=>a,subscribe:t=>(n.add(t),()=>n.delete(t))},a=e=t(r,o,s);return s},y=t=>t,m=t=>{const e=(t=>t?p(t):p)(t),r=t=>function(t,e=y){const r=n.default.useSyncExternalStore(t.subscribe,(()=>e(t.getState())),(()=>e(t.getInitialState())));return n.default.useDebugValue(r),r}(e,t);return Object.assign(r,e),r},g=(t,{devtoolsOptions:e,persistOptions:n}={})=>{let r=t;var o,s;return(null==n?void 0:n.name)&&(o=t,s=Object.assign({},n),r=(t,e,n)=>{let r={storage:f((()=>localStorage)),partialize:t=>t,version:0,merge:(t,e)=>({...e,...t}),...s},a=!1;const i=new Set,c=new Set;let l=r.storage;if(!l)return o(((...e)=>{console.warn(`[zustand persist middleware] Unable to update item '${r.name}', the given storage is currently unavailable.`),t(...e)}),e,n);const u=()=>{const t=r.partialize({...e()});return l.setItem(r.name,{state:t,version:r.version})},d=n.setState;n.setState=(t,e)=>{d(t,e),u()};const p=o(((...e)=>{t(...e),u()}),e,n);let y;n.getInitialState=()=>p;const m=()=>{var n,o;if(!l)return;a=!1,i.forEach((t=>{var n;return t(null!=(n=e())?n:p)}));const s=(null==(o=r.onRehydrateStorage)?void 0:o.call(r,null!=(n=e())?n:p))||void 0;return v(l.getItem.bind(l))(r.name).then((t=>{if(t){if("number"!=typeof t.version||t.version===r.version)return[!1,t.state];if(r.migrate){const e=r.migrate(t.state,t.version);return e instanceof Promise?e.then((t=>[!0,t])):[!0,e]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}return[!1,void 0]})).then((n=>{var o;const[s,a]=n;if(y=r.merge(a,null!=(o=e())?o:p),t(y,!0),s)return u()})).then((()=>{null==s||s(y,void 0),y=e(),a=!0,c.forEach((t=>t(y)))})).catch((t=>{null==s||s(void 0,t)}))};return n.persist={setOptions:t=>{r={...r,...t},t.storage&&(l=t.storage)},clearStorage:()=>{null==l||l.removeItem(r.name)},getOptions:()=>r,rehydrate:()=>m(),hasHydrated:()=>a,onHydrate:t=>(i.add(t),()=>{i.delete(t)}),onFinishHydration:t=>(c.add(t),()=>{c.delete(t)})},r.skipHydration||m(),y||p}),(null==e?void 0:e.enabled)&&(r=((t,e={})=>(n,r,o)=>{const{enabled:s,anonymousActionType:a,store:i,...c}=e;let f;try{f=(null==s||s)&&window.__REDUX_DEVTOOLS_EXTENSION__}catch(t){}if(!f)return t(n,r,o);const{connection:v,...p}=((t,e,n)=>{if(void 0===t)return{type:"untracked",connection:e.connect(n)};const r=l.get(n.name);if(r)return{type:"tracked",store:t,...r};const o={connection:e.connect(n),stores:{}};return l.set(n.name,o),{type:"tracked",store:t,...o}})(i,f,c);let y=!0;o.setState=(t,e,s)=>{const l=n(t,e);if(!y)return l;const d=void 0===s?{type:a||"anonymous"}:"string"==typeof s?{type:s}:s;return void 0===i?(null==v||v.send(d,r()),l):(null==v||v.send({...d,type:`${i}/${d.type}`},{...u(c.name),[i]:o.getState()}),l)};const m=(...t)=>{const e=y;y=!1,n(...t),y=e},g=t(o.setState,r,o);if("untracked"===p.type?null==v||v.init(g):(p.stores[p.store]=o,null==v||v.init(Object.fromEntries(Object.entries(p.stores).map((([t,e])=>[t,t===p.store?g:e.getState()]))))),o.dispatchFromDevtools&&"function"==typeof o.dispatch){let t=!1;const e=o.dispatch;o.dispatch=(...n)=>{"__setState"!==n[0].type||t||(console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'),t=!0),e(...n)}}return v.subscribe((t=>{var e;switch(t.type){case"ACTION":return"string"!=typeof t.payload?void console.error("[zustand devtools middleware] Unsupported action format"):d(t.payload,(t=>{if("__setState"!==t.type)o.dispatchFromDevtools&&"function"==typeof o.dispatch&&o.dispatch(t);else{if(void 0===i)return void m(t.state);1!==Object.keys(t.state).length&&console.error('\n                    [zustand devtools middleware] Unsupported __setState action format.\n                    When using \'store\' option in devtools(), the \'state\' should have only one key, which is a value of \'store\' that was passed in devtools(),\n                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }\n                    ');const e=t.state[i];if(null==e)return;JSON.stringify(o.getState())!==JSON.stringify(e)&&m(e)}}));case"DISPATCH":switch(t.payload.type){case"RESET":return m(g),void 0===i?null==v?void 0:v.init(o.getState()):null==v?void 0:v.init(u(c.name));case"COMMIT":return void 0===i?void(null==v||v.init(o.getState())):null==v?void 0:v.init(u(c.name));case"ROLLBACK":return d(t.state,(t=>{if(void 0===i)return m(t),void(null==v||v.init(o.getState()));m(t[i]),null==v||v.init(u(c.name))}));case"JUMP_TO_STATE":case"JUMP_TO_ACTION":return d(t.state,(t=>{void 0!==i?JSON.stringify(o.getState())!==JSON.stringify(t[i])&&m(t[i]):m(t)}));case"IMPORT_STATE":{const{nextLiftedState:n}=t.payload,r=null==(e=n.computedStates.slice(-1)[0])?void 0:e.state;if(!r)return;return m(void 0===i?r:r[i]),void(null==v||v.send(null,n))}case"PAUSE_RECORDING":return y=!y}return}})),g})(r,Object.assign({},e))),[m(r)]};const S=()=>{const[t]=g(((t,e)=>({isPending:!1,error:null,data:void 0,setPending(e){t({isPending:e})},setData(e){t({data:e})},setError(e){t({error:e})},executeQueryFn({queryFn:t,queryFnFail:n,queryFnSuccess:r}){return o=this,s=void 0,i=function*(){let o;const{setPending:s,setError:a,setData:i}=e();try{s(!0),a(null),o=yield t(),i(o),"function"==typeof r&&r(o)}catch(t){t instanceof Error?a(t.message):a(JSON.stringify(t)),"function"==typeof n&&n(t)}finally{s(!1)}return o},new((a=void 0)||(a=Promise))((function(t,e){function n(t){try{c(i.next(t))}catch(t){e(t)}}function r(t){try{c(i.throw(t))}catch(t){e(t)}}function c(e){var o;e.done?t(e.value):(o=e.value,o instanceof a?o:new a((function(t){t(o)}))).then(n,r)}c((i=i.apply(o,s||[])).next())}));var o,s,a,i}})));return t};export{f as createJSONStorage,S as createQueryStore,g as createStore,c as useShallow};