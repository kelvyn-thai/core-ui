import*as t from"react";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)};const n=(s={default:()=>t.default},a={},e.d(a,s),a),r=t=>{let e;const n=new Set,r=(t,r)=>{const o="function"==typeof t?t(e):t;if(!Object.is(o,e)){const t=e;e=(null!=r?r:"object"!=typeof o||null===o)?o:Object.assign({},e,o),n.forEach((n=>n(e,t)))}},o=()=>e,s={setState:r,getState:o,getInitialState:()=>a,subscribe:t=>(n.add(t),()=>n.delete(t))},a=e=t(r,o,s);return s},o=t=>t;var s,a;const i=t=>{const e=(t=>t?r(t):r)(t),s=t=>function(t,e=o){const r=n.default.useSyncExternalStore(t.subscribe,(()=>e(t.getState())),(()=>e(t.getInitialState())));return n.default.useDebugValue(r),r}(e,t);return Object.assign(s,e),s},l=new Map,c=t=>{const e=l.get(t);return e?Object.fromEntries(Object.entries(e.stores).map((([t,e])=>[t,e.getState()]))):{}},u=(t,e)=>{let n;try{n=JSON.parse(t)}catch(t){console.error("[zustand devtools middleware] Could not parse the received json",t)}void 0!==n&&e(n)};function d(t,e){let n;try{n=t()}catch(t){return}return{getItem:t=>{var r;const o=t=>null===t?null:JSON.parse(t,null==e?void 0:e.reviver),s=null!=(r=n.getItem(t))?r:null;return s instanceof Promise?s.then(o):o(s)},setItem:(t,r)=>n.setItem(t,JSON.stringify(r,null==e?void 0:e.replacer)),removeItem:t=>n.removeItem(t)}}const p=t=>e=>{try{const n=t(e);return n instanceof Promise?n:{then:t=>p(t)(n),catch(t){return this}}}catch(t){return{then(t){return this},catch:e=>p(e)(t)}}},v=(t,{devtoolsOptions:e,persistOptions:n}={})=>{let r=t;var o,s;return(null==n?void 0:n.name)&&(o=t,s=Object.assign({},n),r=(t,e,n)=>{let r={storage:d((()=>localStorage)),partialize:t=>t,version:0,merge:(t,e)=>({...e,...t}),...s},a=!1;const i=new Set,l=new Set;let c=r.storage;if(!c)return o(((...e)=>{console.warn(`[zustand persist middleware] Unable to update item '${r.name}', the given storage is currently unavailable.`),t(...e)}),e,n);const u=()=>{const t=r.partialize({...e()});return c.setItem(r.name,{state:t,version:r.version})},v=n.setState;n.setState=(t,e)=>{v(t,e),u()};const f=o(((...e)=>{t(...e),u()}),e,n);let m;n.getInitialState=()=>f;const y=()=>{var n,o;if(!c)return;a=!1,i.forEach((t=>{var n;return t(null!=(n=e())?n:f)}));const s=(null==(o=r.onRehydrateStorage)?void 0:o.call(r,null!=(n=e())?n:f))||void 0;return p(c.getItem.bind(c))(r.name).then((t=>{if(t){if("number"!=typeof t.version||t.version===r.version)return[!1,t.state];if(r.migrate){const e=r.migrate(t.state,t.version);return e instanceof Promise?e.then((t=>[!0,t])):[!0,e]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}return[!1,void 0]})).then((n=>{var o;const[s,a]=n;if(m=r.merge(a,null!=(o=e())?o:f),t(m,!0),s)return u()})).then((()=>{null==s||s(m,void 0),m=e(),a=!0,l.forEach((t=>t(m)))})).catch((t=>{null==s||s(void 0,t)}))};return n.persist={setOptions:t=>{r={...r,...t},t.storage&&(c=t.storage)},clearStorage:()=>{null==c||c.removeItem(r.name)},getOptions:()=>r,rehydrate:()=>y(),hasHydrated:()=>a,onHydrate:t=>(i.add(t),()=>{i.delete(t)}),onFinishHydration:t=>(l.add(t),()=>{l.delete(t)})},r.skipHydration||y(),m||f}),(null==e?void 0:e.enabled)&&(r=((t,e={})=>(n,r,o)=>{const{enabled:s,anonymousActionType:a,store:i,...d}=e;let p;try{p=(null==s||s)&&window.__REDUX_DEVTOOLS_EXTENSION__}catch(t){}if(!p)return t(n,r,o);const{connection:v,...f}=((t,e,n)=>{if(void 0===t)return{type:"untracked",connection:e.connect(n)};const r=l.get(n.name);if(r)return{type:"tracked",store:t,...r};const o={connection:e.connect(n),stores:{}};return l.set(n.name,o),{type:"tracked",store:t,...o}})(i,p,d);let m=!0;o.setState=(t,e,s)=>{const l=n(t,e);if(!m)return l;const u=void 0===s?{type:a||"anonymous"}:"string"==typeof s?{type:s}:s;return void 0===i?(null==v||v.send(u,r()),l):(null==v||v.send({...u,type:`${i}/${u.type}`},{...c(d.name),[i]:o.getState()}),l)};const y=(...t)=>{const e=m;m=!1,n(...t),m=e},S=t(o.setState,r,o);if("untracked"===f.type?null==v||v.init(S):(f.stores[f.store]=o,null==v||v.init(Object.fromEntries(Object.entries(f.stores).map((([t,e])=>[t,t===f.store?S:e.getState()]))))),o.dispatchFromDevtools&&"function"==typeof o.dispatch){let t=!1;const e=o.dispatch;o.dispatch=(...n)=>{"__setState"!==n[0].type||t||(console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'),t=!0),e(...n)}}return v.subscribe((t=>{var e;switch(t.type){case"ACTION":return"string"!=typeof t.payload?void console.error("[zustand devtools middleware] Unsupported action format"):u(t.payload,(t=>{if("__setState"!==t.type)o.dispatchFromDevtools&&"function"==typeof o.dispatch&&o.dispatch(t);else{if(void 0===i)return void y(t.state);1!==Object.keys(t.state).length&&console.error('\n                    [zustand devtools middleware] Unsupported __setState action format.\n                    When using \'store\' option in devtools(), the \'state\' should have only one key, which is a value of \'store\' that was passed in devtools(),\n                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }\n                    ');const e=t.state[i];if(null==e)return;JSON.stringify(o.getState())!==JSON.stringify(e)&&y(e)}}));case"DISPATCH":switch(t.payload.type){case"RESET":return y(S),void 0===i?null==v?void 0:v.init(o.getState()):null==v?void 0:v.init(c(d.name));case"COMMIT":return void 0===i?void(null==v||v.init(o.getState())):null==v?void 0:v.init(c(d.name));case"ROLLBACK":return u(t.state,(t=>{if(void 0===i)return y(t),void(null==v||v.init(o.getState()));y(t[i]),null==v||v.init(c(d.name))}));case"JUMP_TO_STATE":case"JUMP_TO_ACTION":return u(t.state,(t=>{void 0!==i?JSON.stringify(o.getState())!==JSON.stringify(t[i])&&y(t[i]):y(t)}));case"IMPORT_STATE":{const{nextLiftedState:n}=t.payload,r=null==(e=n.computedStates.slice(-1)[0])?void 0:e.state;if(!r)return;return y(void 0===i?r:r[i]),void(null==v||v.send(null,n))}case"PAUSE_RECORDING":return m=!m}return}})),S})(r,Object.assign({},e))),[i(r)]},f=t=>Symbol.iterator in t,m=t=>"entries"in t,y=(t,e)=>{const n=t instanceof Map?t:new Map(t.entries()),r=e instanceof Map?e:new Map(e.entries());if(n.size!==r.size)return!1;for(const[t,e]of n)if(!Object.is(e,r.get(t)))return!1;return!0};function S(t){const e=n.default.useRef(void 0);return n=>{const r=t(n);return o=e.current,s=r,Object.is(o,s)||"object"==typeof o&&null!==o&&"object"==typeof s&&null!==s&&(f(o)&&f(s)?m(o)&&m(s)?y(o,s):((t,e)=>{const n=t[Symbol.iterator](),r=e[Symbol.iterator]();let o=n.next(),s=r.next();for(;!o.done&&!s.done;){if(!Object.is(o.value,s.value))return!1;o=n.next(),s=r.next()}return!!o.done&&!!s.done})(o,s):y({entries:()=>Object.entries(o)},{entries:()=>Object.entries(s)}))?e.current:e.current=r;var o,s}}export{v as createStore,S as useShallow};