"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const x=require("react"),P=require("zustand"),w=r=>Symbol.iterator in r,T=r=>"entries"in r,N=(r,t)=>{const o=r instanceof Map?r:new Map(r.entries()),e=t instanceof Map?t:new Map(t.entries());if(o.size!==e.size)return!1;for(const[n,i]of o)if(!e.has(n)||!Object.is(i,e.get(n)))return!1;return!0},k=(r,t)=>{const o=r[Symbol.iterator](),e=t[Symbol.iterator]();let n=o.next(),i=e.next();for(;!n.done&&!i.done;){if(!Object.is(n.value,i.value))return!1;n=o.next(),i=e.next()}return!!n.done&&!!i.done};function J(r,t){return Object.is(r,t)?!0:typeof r!="object"||r===null||typeof t!="object"||t===null||Object.getPrototypeOf(r)!==Object.getPrototypeOf(t)?!1:w(r)&&w(t)?T(r)&&T(t)?N(r,t):k(r,t):N({entries:()=>Object.entries(r)},{entries:()=>Object.entries(t)})}function L(r){const t=x.useRef(void 0);return o=>{const e=r(o);return J(t.current,e)?t.current:t.current=e}}const R={BASE_URL:"/",DEV:!1,MODE:"production",PROD:!0,SSR:!1,VITE_BUNDLE_ANALYZER:"false",VITE_USER_NODE_ENV:"development"},_=new Map,b=r=>{const t=_.get(r);return t?Object.fromEntries(Object.entries(t.stores).map(([o,e])=>[o,e.getState()])):{}},M=(r,t,o)=>{if(r===void 0)return{type:"untracked",connection:t.connect(o)};const e=_.get(o.name);if(e)return{type:"tracked",store:r,...e};const n={connection:t.connect(o),stores:{}};return _.set(o.name,n),{type:"tracked",store:r,...n}},U=(r,t)=>{if(t===void 0)return;const o=_.get(r);o&&(delete o.stores[t],Object.keys(o.stores).length===0&&_.delete(r))},H=r=>{var t,o;if(!r)return;const e=r.split(`
`),n=e.findIndex(m=>m.includes("api.setState"));if(n<0)return;const i=((t=e[n+1])==null?void 0:t.trim())||"";return(o=/.+ (.+) .+/.exec(i))==null?void 0:o[1]},F=(r,t={})=>(o,e,n)=>{const{enabled:i,anonymousActionType:m,store:l,...d}=t;let S;try{S=(i??(R?"production":void 0)!=="production")&&window.__REDUX_DEVTOOLS_EXTENSION__}catch{}if(!S)return r(o,e,n);const{connection:a,...h}=M(l,S,d);let p=!0;n.setState=((s,f,c)=>{const u=o(s,f);if(!p)return u;const y=c===void 0?{type:m||H(new Error().stack)||"anonymous"}:typeof c=="string"?{type:c}:c;return l===void 0?(a?.send(y,e()),u):(a?.send({...y,type:`${l}/${y.type}`},{...b(d.name),[l]:n.getState()}),u)}),n.devtools={cleanup:()=>{a&&typeof a.unsubscribe=="function"&&a.unsubscribe(),U(d.name,l)}};const v=(...s)=>{const f=p;p=!1,o(...s),p=f},g=r(n.setState,e,n);if(h.type==="untracked"?a?.init(g):(h.stores[h.store]=n,a?.init(Object.fromEntries(Object.entries(h.stores).map(([s,f])=>[s,s===h.store?g:f.getState()])))),n.dispatchFromDevtools&&typeof n.dispatch=="function"){let s=!1;const f=n.dispatch;n.dispatch=(...c)=>{(R?"production":void 0)!=="production"&&c[0].type==="__setState"&&!s&&(console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'),s=!0),f(...c)}}return a.subscribe(s=>{var f;switch(s.type){case"ACTION":if(typeof s.payload!="string"){console.error("[zustand devtools middleware] Unsupported action format");return}return I(s.payload,c=>{if(c.type==="__setState"){if(l===void 0){v(c.state);return}Object.keys(c.state).length!==1&&console.error(`
                    [zustand devtools middleware] Unsupported __setState action format.
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `);const u=c.state[l];if(u==null)return;JSON.stringify(n.getState())!==JSON.stringify(u)&&v(u);return}n.dispatchFromDevtools&&typeof n.dispatch=="function"&&n.dispatch(c)});case"DISPATCH":switch(s.payload.type){case"RESET":return v(g),l===void 0?a?.init(n.getState()):a?.init(b(d.name));case"COMMIT":if(l===void 0){a?.init(n.getState());return}return a?.init(b(d.name));case"ROLLBACK":return I(s.state,c=>{if(l===void 0){v(c),a?.init(n.getState());return}v(c[l]),a?.init(b(d.name))});case"JUMP_TO_STATE":case"JUMP_TO_ACTION":return I(s.state,c=>{if(l===void 0){v(c);return}JSON.stringify(n.getState())!==JSON.stringify(c[l])&&v(c[l])});case"IMPORT_STATE":{const{nextLiftedState:c}=s.payload,u=(f=c.computedStates.slice(-1)[0])==null?void 0:f.state;if(!u)return;v(l===void 0?u:u[l]),a?.send(null,c);return}case"PAUSE_RECORDING":return p=!p}return}}),g},z=F,I=(r,t)=>{let o;try{o=JSON.parse(r)}catch(e){console.error("[zustand devtools middleware] Could not parse the received json",e)}o!==void 0&&t(o)};function j(r,t){let o;try{o=r()}catch{return}return{getItem:n=>{var i;const m=d=>d===null?null:JSON.parse(d,t?.reviver),l=(i=o.getItem(n))!=null?i:null;return l instanceof Promise?l.then(m):m(l)},setItem:(n,i)=>o.setItem(n,JSON.stringify(i,t?.replacer)),removeItem:n=>o.removeItem(n)}}const E=r=>t=>{try{const o=r(t);return o instanceof Promise?o:{then(e){return E(e)(o)},catch(e){return this}}}catch(o){return{then(e){return this},catch(e){return E(e)(o)}}}},A=(r,t)=>(o,e,n)=>{let i={storage:j(()=>localStorage),partialize:s=>s,version:0,merge:(s,f)=>({...f,...s}),...t},m=!1;const l=new Set,d=new Set;let S=i.storage;if(!S)return r((...s)=>{console.warn(`[zustand persist middleware] Unable to update item '${i.name}', the given storage is currently unavailable.`),o(...s)},e,n);const a=()=>{const s=i.partialize({...e()});return S.setItem(i.name,{state:s,version:i.version})},h=n.setState;n.setState=(s,f)=>(h(s,f),a());const p=r((...s)=>(o(...s),a()),e,n);n.getInitialState=()=>p;let v;const g=()=>{var s,f;if(!S)return;m=!1,l.forEach(u=>{var y;return u((y=e())!=null?y:p)});const c=((f=i.onRehydrateStorage)==null?void 0:f.call(i,(s=e())!=null?s:p))||void 0;return E(S.getItem.bind(S))(i.name).then(u=>{if(u)if(typeof u.version=="number"&&u.version!==i.version){if(i.migrate){const y=i.migrate(u.state,u.version);return y instanceof Promise?y.then(O=>[!0,O]):[!0,y]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,u.state];return[!1,void 0]}).then(u=>{var y;const[O,D]=u;if(v=i.merge(D,(y=e())!=null?y:p),o(v,!0),O)return a()}).then(()=>{c?.(v,void 0),v=e(),m=!0,d.forEach(u=>u(v))}).catch(u=>{c?.(void 0,u)})};return n.persist={setOptions:s=>{i={...i,...s},s.storage&&(S=s.storage)},clearStorage:()=>{S?.removeItem(i.name)},getOptions:()=>i,rehydrate:()=>g(),hasHydrated:()=>m,onHydrate:s=>(l.add(s),()=>{l.delete(s)}),onFinishHydration:s=>(d.add(s),()=>{d.delete(s)})},i.skipHydration||g(),v||p},Q=A,C=(r,{devtoolsOptions:t,persistOptions:o}={})=>{let e=r;return o?.name&&(e=Q(r,{...o})),t?.enabled&&(e=z(e,{...t})),[P.create()(e)]},$=()=>{const[r]=C((t,o)=>({isPending:!1,error:null,data:void 0,setPending(e){t({isPending:e})},setData(e){t({data:e})},setError(e){t({error:e})},async executeQueryFn({queryFn:e,queryFnFail:n,queryFnSuccess:i}){let m;const{setPending:l,setError:d,setData:S}=o();try{l(!0),d(null),m=await e(),S(m),typeof i=="function"&&i(m)}catch(a){a instanceof Error?d(a.message):d(JSON.stringify(a)),typeof n=="function"&&n(a)}finally{l(!1)}return m}}));return r};exports.createJSONStorage=j;exports.createQueryStore=$;exports.createStore=C;exports.useShallow=L;
